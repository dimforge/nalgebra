#[cfg(feature = "serde-serialize-no-std")]
use serde::{Deserialize, Serialize};

use crate::allocator::Allocator;
use crate::base::{Const, DefaultAllocator, OMatrix, OVector};
use crate::dimension::Dim;
use simba::scalar::RealField;
use std::cmp::Ordering;

/// LDL factorization.
#[cfg_attr(feature = "serde-serialize-no-std", derive(Serialize, Deserialize))]
#[cfg_attr(
    feature = "serde-serialize-no-std",
    serde(bound(serialize = "OVector<T, D>: Serialize, OMatrix<T, D, D>: Serialize"))
)]
#[cfg_attr(
    feature = "serde-serialize-no-std",
    serde(bound(
        deserialize = "OVector<T, D>: Deserialize<'de>, OMatrix<T, D, D>: Deserialize<'de>"
    ))
)]
#[derive(Clone, Debug)]
pub struct LDL<T: RealField, D: Dim>
where
    DefaultAllocator: Allocator<D> + Allocator<D, D>,
{
    /// The lower triangular matrix resulting from the factorization
    pub l: OMatrix<T, D, D>,
    /// The diagonal matrix resulting from the factorization
    pub d: OVector<T, D>,
}

impl<T: RealField, D: Dim> Copy for LDL<T, D>
where
    DefaultAllocator: Allocator<D> + Allocator<D, D>,
    OVector<T, D>: Copy,
    OMatrix<T, D, D>: Copy,
{
}

impl<T: RealField, D: Dim> LDL<T, D>
where
    DefaultAllocator: Allocator<D> + Allocator<D, D>,
{
    /// Computes the LDL^T factorization.
    ///
    /// The input matrix `p` is assumed to be symmetric and this decomposition will only read
    /// the lower-triangular part of `p`.
    pub fn new(p: OMatrix<T, D, D>) -> Option<Self> {
        let n = p.ncols();

        let n_dim = p.shape_generic().1;

        let mut d = OVector::<T, D>::zeros_generic(n_dim, Const::<1>);
        let mut l = OMatrix::<T, D, D>::zeros_generic(n_dim, n_dim);

        for j in 0..n {
            let mut d_j = p[(j, j)].clone();

            if j > 0 {
                for k in 0..j {
                    d_j -= d[k].clone() * l[(j, k)].clone().powi(2);
                }
            }

            d[j] = d_j;

            for i in j..n {
                let mut l_ij = p[(j, i)].clone();

                for k in 0..j {
                    l_ij -= d[k].clone() * l[(j, k)].clone() * l[(i, k)].clone();
                }

                if matches!(d[j].partial_cmp(&T::zero())?, Ordering::Equal) {
                    l[(i, j)] = T::zero();
                } else {
                    l[(i, j)] = l_ij / d[j].clone();
                }
            }
        }

        Some(Self { l, d })
    }

    /// Returns the lower triangular matrix as if generated by the Cholesky decomposition.
    pub fn cholesky_l(&self) -> OMatrix<T, D, D> {
        let n_dim = self.l.shape_generic().1;

        &self.l
            * OMatrix::from_diagonal(&OVector::from_iterator_generic(
                n_dim,
                Const::<1>,
                self.d.iter().map(|value| value.clone().sqrt()),
            ))
    }

    /// Returns the diagonal elements as a matrix
    #[must_use]
    pub fn d_matrix(&self) -> OMatrix<T, D, D> {
        OMatrix::from_diagonal(&self.d)
    }
}
