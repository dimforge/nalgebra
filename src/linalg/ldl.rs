#[cfg(feature = "serde-serialize-no-std")]
use serde::{Deserialize, Serialize};

use crate::allocator::Allocator;
use crate::base::{Const, DefaultAllocator, OMatrix, OVector};
use crate::dimension::Dim;
use simba::scalar::ComplexField;

/// The LDL / LDL^T factorization of a Hermitian matrix A = LDL^T where L is a lower unit-triangular matrix and D is diagonal matrix.
#[cfg_attr(feature = "serde-serialize-no-std", derive(Serialize, Deserialize))]
#[cfg_attr(
    feature = "serde-serialize-no-std",
    serde(bound(serialize = "OMatrix<T, D, D>: Serialize"))
)]
#[cfg_attr(
    feature = "serde-serialize-no-std",
    serde(bound(deserialize = "OMatrix<T, D, D>: Deserialize<'de>"))
)]
#[derive(Clone, Debug)]
pub struct LDL<T: ComplexField, D: Dim>(OMatrix<T, D, D>)
where
    DefaultAllocator: Allocator<D> + Allocator<D, D>;

impl<T: ComplexField, D: Dim> Copy for LDL<T, D>
where
    DefaultAllocator: Allocator<D> + Allocator<D, D>,
    OMatrix<T, D, D>: Copy,
{
}

impl<T: ComplexField, D: Dim> LDL<T, D>
where
    DefaultAllocator: Allocator<D> + Allocator<D, D>,
{
    /// Returns the diagonal elements as a vector.
    #[must_use]
    pub fn d(&self) -> OVector<T, D> {
        self.0.diagonal()
    }

    /// Returns the diagonal elements as a matrix.
    #[must_use]
    pub fn d_matrix(&self) -> OMatrix<T, D, D> {
        OMatrix::from_diagonal(&self.0.diagonal())
    }

    /// Returns the lower triangular matrix.
    #[must_use]
    pub fn l_matrix(&self) -> OMatrix<T, D, D> {
        let mut l = self.0.clone();

        l.column_iter_mut()
            .enumerate()
            .for_each(|(idx, mut column)| {
                column[idx] = T::one();
            });

        l
    }

    /// Returns the matrix L * sqrt(D).
    /// This function returns `None` if the square root of any of the values in the diagonal matrix D is not finite.
    ///
    /// This function can be used to generate a lower triangular matrix as if it were generated by the Cholesky decomposition, without the requirement of positive definiteness.
    pub fn lsqrtd(&self) -> Option<OMatrix<T, D, D>> {
        let n_dim = self.0.shape_generic().1;

        let lsqrtd: crate::Matrix<T, D, D, <DefaultAllocator as Allocator<D, D>>::Buffer<T>> = &self
            .l_matrix()
            * OMatrix::from_diagonal(&OVector::from_iterator_generic(
                n_dim,
                Const::<1>,
                self.d().iter().map(|value| value.clone().sqrt()),
            ));

        // Check for any non-finite numbers in lsqrtd and return None if necessary.
        if !lsqrtd.iter().fold(true, |acc, next| acc & next.is_finite()) {
            None
        } else {
            Some(lsqrtd)
        }
    }

    /// Computes the LDL / LDL^T factorization.
    pub fn new(mut matrix: OMatrix<T, D, D>) -> Option<Self> {
        for j in 0..matrix.ncols() {
            let mut d_j: T = matrix[(j, j)].clone();

            if j > 0 {
                for k in 0..j {
                    d_j -= matrix[(j, k)].clone()
                        * matrix[(j, k)].clone().conjugate()
                        * matrix[(k, k)].clone();
                }
            }

            matrix[(j, j)] = d_j;

            for i in (j + 1)..matrix.ncols() {
                let mut l_ij = matrix[(i, j)].clone();

                for k in 0..j {
                    l_ij -= matrix[(j, k)].clone().conjugate()
                        * matrix[(i, k)].clone()
                        * matrix[(k, k)].clone();
                }

                if matrix[(j, j)] == T::zero() {
                    matrix[(i, j)] = T::zero();
                } else {
                    matrix[(i, j)] = l_ij / matrix[(j, j)].clone();
                }

                // Zero out the upper triangular part.
                matrix[(j, i)] = T::zero();
            }
        }

        Some(Self(matrix))
    }
}
