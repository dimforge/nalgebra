use na::{Matrix2, Matrix4x2, U3, U4};

#[test]
fn simple_qr() {
    #[rustfmt::skip]
    let a = Matrix4x2::new(
        -0.8943285241224914 ,  0.12787800716234649,
        -0.37320804072796987,  0.21338804264385058,
         0.                 , -0.2456767687354977 ,
         0.2456767687354977 ,  0.                 );
    let qr = a.qr();
    // the reference values were generated by converting the input
    // to the form `m * 2 ^ e` for integers m and e. This was then used to
    // obtain the QR decomposition without rounding errors. The result was
    // converted back to f64.
    #[rustfmt::skip]
    let r_ref = Matrix2::new(
        0.99973237689865724, -0.19405501632841561,
        0.                 , -0.2908383860381578);
    assert_relative_eq!(qr.r(), r_ref);

    #[rustfmt::skip]
    let q_ref = Matrix4x2::new(
        -0.89456793116659196,  0.15719172406996297, 
        -0.3733079465583837 , -0.48461884587835711,
         0.                 ,  0.8447191998351451, 
         0.24574253511487697, -0.1639658791740342);
    assert_relative_eq!(qr.q(), q_ref);
}

#[test]
fn q_columns() {
    let a = Matrix4x2::new(0., 1., 3., 3., 1., 1., 2., 1.);
    let qr = a.qr();
    assert!(qr.q_columns(U4).is_orthogonal(1.0e-15));
}

#[test]
#[should_panic]
fn q_columns_panic() {
    Matrix2::<f64>::zeros().qr().q_columns(U3);
}

#[cfg(feature = "arbitrary")]
mod quickcheck_test {
    macro_rules! gen_tests(
        ($module: ident, $scalar: ty) => {
            mod $module {
                use na::{DMatrix, DVector, Matrix3x5, Matrix4, Matrix4x3, Matrix5x3, Vector4};
                use std::cmp;
                #[allow(unused_imports)]
                use crate::core::helper::{RandScalar, RandComplex};

                quickcheck! {
                    fn qr(m: DMatrix<$scalar>) -> bool {
                        let m = m.map(|e| e.0);
                        let qr = m.clone().qr();
                        let q  = qr.q();
                        let r  = qr.r();

                        relative_eq!(m, &q * r, epsilon = 1.0e-9) &&
                        q.is_orthogonal(1.0e-15)
                    }

                    fn qr_static_5_3(m: Matrix5x3<$scalar>) -> bool {
                        let m = m.map(|e| e.0);
                        let qr = m.qr();
                        let q  = qr.q();
                        let r  = qr.r();

                        relative_eq!(m, q * r, epsilon = 1.0e-8) &&
                        q.is_orthogonal(1.0e-15)
                    }

                    fn qr_static_3_5(m: Matrix3x5<$scalar>) -> bool {
                        let m = m.map(|e| e.0);
                        let qr = m.qr();
                        let q  = qr.q();
                        let r  = qr.r();

                        relative_eq!(m, q * r, epsilon = 1.0e-9) &&
                        q.is_orthogonal(1.0e-15)
                    }

                    fn qr_static_square(m: Matrix4<$scalar>) -> bool {
                        let m = m.map(|e| e.0);
                        let qr = m.qr();
                        let q  = qr.q();
                        let r  = qr.r();

                        relative_eq!(m, q * r, epsilon = 1.0e-9) &&
                        q.is_orthogonal(1.0e-15)
                    }

                    fn qr_solve(n: usize, nb: usize) -> bool {
                        if n != 0 && nb != 0 {
                            let n  = cmp::min(n, 50);  // To avoid slowing down the test too much.
                            let nb = cmp::min(nb, 50); // To avoid slowing down the test too much.
                            let m  = DMatrix::<$scalar>::new_random(n, n).map(|e| e.0);

                            let mut qr = m.clone().qr();
                            let b1 = DVector::<$scalar>::new_random(n).map(|e| e.0);
                            let b2 = DMatrix::<$scalar>::new_random(n, nb).map(|e| e.0);

                            if qr.is_invertible() {
                                let sol1 = qr.solve(&b1).unwrap();
                                let sol2 = qr.solve(&b2).unwrap();

                                return relative_eq!(&m * sol1, b1, epsilon = 1.0e-8) &&
                                    relative_eq!(&m * sol2, b2, epsilon = 1.0e-8)
                            }
                        }

                        return true;
                    }

                    fn qr_solve_static(m: Matrix4<$scalar>) -> bool {
                        let m = m.map(|e| e.0);
                        let mut qr = m.qr();
                        let b1 = Vector4::<$scalar>::new_random().map(|e| e.0);
                        let b2 = Matrix4x3::<$scalar>::new_random().map(|e| e.0);

                        if qr.is_invertible() {
                            let sol1 = qr.solve(&b1).unwrap();
                            let sol2 = qr.solve(&b2).unwrap();

                            relative_eq!(m * sol1, b1, epsilon = 1.0e-8) &&
                            relative_eq!(m * sol2, b2, epsilon = 1.0e-8)
                        }
                        else {
                            false
                        }
                    }

                    fn qr_inverse(n: usize) -> bool {
                        let n = cmp::max(1, cmp::min(n, 15)); // To avoid slowing down the test too much.
                        let m = DMatrix::<$scalar>::new_random(n, n).map(|e| e.0);

                        if let Some(m1) = m.clone().qr().try_inverse() {
                            let id1 = &m  * &m1;
                            let id2 = &m1 * &m;

                            id1.is_identity(1.0e-7) && id2.is_identity(1.0e-7)
                        }
                        else {
                            true
                        }
                    }

                    fn qr_inverse_static(m: Matrix4<$scalar>) -> bool {
                        let m  = m.map(|e| e.0);
                        let mut qr = m.qr();

                        if let Some(m1) = qr.try_inverse() {
                            let id1 = &m  * &m1;
                            let id2 = &m1 * &m;

                            id1.is_identity(1.0e-7) && id2.is_identity(1.0e-7)
                        }
                        else {
                            true
                        }
                    }
                }
            }
        }
    );

    gen_tests!(complex, RandComplex<f64>);
    gen_tests!(f64, RandScalar<f64>);
}
